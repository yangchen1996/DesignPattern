### 创建型模式
- 单例模式
    > 某个类只能生成一个实例，该类提供一个全局访问点供外部获取该实例。
    比如：Windows 中只能打开一个任务管理器，这样可以避免因打开多个任务管理器窗口而造成内存资源的浪费，或出现各个窗口显示内容的不一致等错误。
    ##### 适合的场景的特点：
        - 某个类只需要生成一个对象的时候，如一个班中的班长。
        - 当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 Web 中的配置对象、数据库的连接池等。
        - 当某类需要频繁实例化，而创建的对象又频繁被销毁的时候，如多线程的线程池、网络连接池等。
    ##### 拓展：
        - 有限的多例模式，生成有限个实例保存在List中，需要时随机获取。
    ##### 理解：
        - 整个系统只需要一个该类的实例时。
        
- 原型模式
    >将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。
    比如：安装软件时，复制比重新安装快很多。
    
    >浅克隆：被复制对象的所有普通成员变量都具有与原来对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。也就是说，浅克隆仅仅复制所考虑的对象，不会复制它所引用的成员对象。
    
    >深克隆：被复制的对象的所有普通成员变量也都含有与原来的对象相同的值，出去那些引用其他对象的变量。换言之，在深克隆中，除了对象本身被复制外，对象包含的引用也被复制，也就是其中的成员对象也被复制。
    ##### 适合的场景的特点：
        - 对象之间相同或相似，即只是个别的几个属性不同的时候。
        - 对象的创建过程比较麻烦，但复制比较简单的时候。
    ##### 拓展：
        - 原型模式可扩展为带原型管理器的原型模式，它在原型模式的基础上增加了一个原型管理器 PrototypeManager 类。该类用 HashMap 保存多个复制的原型，Client 类可以通过管理器的 get(String id) 方法从中获取复制的原型。
    ##### 理解：
        - 创建实例比较复杂，并且已经存在一个实例时，且只有个别属性不同时。
        
- 工厂方法模式
    >定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。
    ##### 缺点：
        - 每增加一个产品就要增加一个具体产品类和具体工厂类。
    ##### 优点：
        - 只需要知道工厂名就能得到想要的产品，无需知道具体的创建过程。
        - 增加新产品时只需要添加产品类和工厂类，无需对原工厂进行任何修改。
    ##### 适合的场景的特点：
        - 客户只知道创建产品的工厂名，而不知道具体的产品名。
        - 创建对象的任务由多个工厂中的一个完成，抽象工厂只提供创建接口。
        - 客户不关心创建产品的细节，只关心产品的品牌。
    ##### 理解：
        - 创建对象时需要初始化很多参数，不需要知道创建过程，只管使用，减少错误创建。
        - 有多个构造方法，可以将多个方法提成不同的工厂，命名更友好，可以体现不同实例的特征。
        - 为了解耦：把对象的创建和使用的过程分开。将实例化交给工厂类。

- 抽象工厂模式
    >是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。
    ##### 缺点：
        - 当产品族中需要增加一个新产品时，所有的工厂类都要进行修改。
    ##### 优点：
        - 可以在类的内部对产品族的多产品进行管理。
        - 增加一个产品族时，不需要修改原代码。
    ##### 适合的场景的特点：
        - 当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。
        - 系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。
        - 系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。
    ##### 理解：
        - 需要同时创建一组对象的实例。
        - 根据情况的不同会创建不同的实例。
        
- 建造者模式
    >指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示。
    它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。
    ##### 注：
        - 建造者（Builder）模式和工厂模式的关注点不同：建造者模式注重零部件的组装过程，而工厂方法模式更注重零部件的创建过程，但两者可以结合使用。
    ##### 缺点：
        - 产品的组成部分必须相同，这限制了其使用范围。
        - 如果产品的内部变化复杂，该模式会增加很多的建造者类。
    ##### 优点：
        - 各个具体的建造者相互独立，有利于系统的扩展。
        - 客户端不必知道产品内部组成的细节，便于控制细节风险。
    ##### 适合的场景的特点：
        - 创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的。
        - 创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表示是独立的。
    ##### 理解：
        - 需要按照一定顺序去赋值属性时，将易出错的部分分离。
        - 同一个类的多个实例的结构相同，但是各属性的赋值产生方式不同时，即实例结构不变，各属性变化频繁。
        
        
### 结构型模式
- 代理模式
    >由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。
    比如：访问机密资源时,本身的访问方法没有做权限查看，这时需要代理这个实例，在访问之前进行一些操作。
    ##### 优点：
        - 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；
        - 代理对象可以扩展目标对象的功能；
        - 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；
    ##### 缺点：
        - 在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；
        - 增加了系统的复杂度；
    ##### 适合的场景的特点：
        - SpringAOP 切面编程：给指定的类设置代理，在指定的位置添加关注点(即：额外操作)。
        - 在进行实际操作前，需要进行额外操作时，需要给实际的类添加代理。
        - 保护实际的类调用。

    